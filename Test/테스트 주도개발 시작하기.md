#TDD

> `최범균 - 테스트 주도 개발 시작하기`를 보고 정리한 글

<!--[TOC]: # "## Table of Contents"-->

## Table of Contents
- [TDD란?](#tdd란)
- [환경설정](#환경설정)
- [테스트 코드 작성 순서](#테스트-코드-작성-순서)
  - [완급조절](#완급조절)
  - [지속적인 리팩토링](#지속적인-리팩토링)
- [TDD.기능 명세.설계](#tdd기능-명세설계)
  - [필요한 만큼만 설계하기](#필요한-만큼만-설계하기)
  - [기능 명세 구체화](#기능-명세-구체화)
- [JUnit 5 기초](#junit-5-기초)
  - [주요 메서드](#주요-메서드)
  - [테스트 라이프 사이클](#테스트-라이프-사이클)
- [테스트 코드 구성](#테스트-코드-구성)
  - [구성요소 : 상황, 실행, 결과 확인](#구성요소--상황-실행-결과-확인)
  - [외부 상태가 테스트 결과에 영향을 주지 않게 하기](#외부-상태가-테스트-결과에-영향을-주지-않게-하기)
  - [외부 상태와 테스트 어려움](#외부-상태와-테스트-어려움)
- [대역](#대역)
  - [대역의 종류](#대역의-종류)
  - [상황과 결과 확인을 위한 협업 대상(의존) 도출과 대역 사용](#상황과-결과-확인을-위한-협업-대상의존-도출과-대역-사용)
  - [모의 객체를 과하게 사용하지 않기](#모의-객체를-과하게-사용하지-않기)
- [테스트 가능한 설계](#테스트-가능한-설계)
  - [테스트가 어려운 코드](#테스트가-어려운-코드)
- [테스트 범위와 종류](#테스트-범위와-종류)
  - [단위 테스트 (Unit Test)](#단위-테스트-unit-test)
  - [통합테스트 (Integration Test)](#통합테스트-integration-test)
  - [기능테스트 (Functional Test)](#기능테스트-functional-test)
  - [테스트 범위간 차이](#테스트-범위간-차이)


## TDD란?
TDD는 테스트부터 시작한다.
구현을 먼저 하는것이 아닌 테스트 케이스를 먼저 만든다음 구현을 뒤로 미룬다.
기능을 검증하는 테스트 코드를 먼저 작성하고 테스트를 통과시키기 위해 개발을 진행하는것을 의미한다.
작성한 테스트를 통과하지 못하면 테스트를 통과할 만큼만 코드를 작성한다.
테스트를 통과한 뒤에는 개선할 코드가 있으면 리팩토링한다.
리팩토링을 수행한 뒤에는 다시 테스트를 실행해서 기존 기능이 망가지지 않았는지 확인한다.
이 과정을 반복하면서 점진적으로 기능을 완성해 나가는 것, 이것이 전형적인 TDD의 흐름이다.


테스트코드를 작성할 때 `src/main/java`에 먼저 만들기 보다는 `src/test/java`에 먼저 구현한뒤 테스트 코드가 완성되면 `src/main/java`로 이동한다. 이렇게 한다면 완성되지 않은 코드가 배포되는 것을 방지하는 효과가 있다.


> **레드-그린-리팩터**
> TDD 사이클을 Red-Green-Refactor로 부르기도 한다.
> 여기서 레드는 실패하는 테스트를 의미한다. 테드는 테스트 코드가 실패하면 빨간색을 이용해서 실패한 테스트를 보여주는데서 비롯했다.
> 비슷하게 그린은 성공한 테스트를 의미한다. 즉 코드를 구현해서 실패하는 테스트를 통과시키는 것을 뜻한다.
> 마지막으로 리팩터는 이름 그대로 리팩토링 과정을 의미한다.


## 환경설정
Gradle 프로젝트에서 JUnit 설정
``` gradle
plugins {
    id 'java'
}

sourceCompatibility = '11'
targetCompatibility = '11'
compileJava.options.encoding = 'UTF-8'
compileTestJava.options.encoding = 'UTF-8'

repositories {
    mavenCentral()
}

dependencies {
    testImplementation('org.junit.jupiter:junit-jupiter:5.5.0')
}

test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}
```

## 테스트 코드 작성 순서
- 쉬운 경우에서 어려운 경우로 진행
- 예외적인 경우에서 정상인 경우로 진행

반대로 어려운 경우를 먼저 시작하거나 정상 상황을 먼저 시작하면 구현 과정이 원활하게 진행되지 않기도 한다.

1. 구현하기 쉬운 테스트부터 시작
	- 구현하기 어려운 테스트부터 시작하면 구현해야 할 코드량이 많아진다.
	- 한 번에 구현하는 시간이 짧아지면 디버깅 할 때에 유리하다. 작성한 코드가 많지 않고 작성 시간도 짧으면 머릿속에 코드에 대한 내용이 생생하게 남아 있기 때문에 디버깅 할 떄 문제 원인을 빠르게 찾을 수 잇다.
2. 예외 상황을 먼저 테스트
	- 초반에 예외를 처리하지 않으면 코드를 복잡하게 만들면 버그 발생 가능성을 높인다.
	- 예외 상황에 따른 if-else 구조가 미리 만들어지기 떄문에 많은 코드를 완성한 뒤에 예외 상황을 반영할 때보다 코드 구조가 덜 바뀐다.

### 완급조절
테스트 코드를 작성할때는 하드코딩으로 테스트를 통과시키고 그 다음에 하드코딩했던 상수를 제거하고 구현을 일반화한다.
몇 차례 상수를 사용해서 테스트를 통과시키고 뒤에 구현을 일반화 하는 과정이 처음에는 지루하게 느껴질 수도 있지만 이런 연습 과정은 나중에 만들어야 할 코드가 잘 떠오르지 않을 때 점진적으로 구현을 진행할 수 있는 밑거름이 된다.

### 지속적인 리팩토링
테스트를 통과하면 리팩토링을 진행한다.
매번 리팩토링을 진행하는것은 아니지만 적당한 후보가 보이면 리팩토링을 진행한다.
코드 중복은 대표적인 리팩토링 대상이고 코드가 길어지면 메서드 추출과 같은 기법을 사용해서 메서드 이름으로 코드의 의미를 표현할 수 있다.


## TDD.기능 명세.설계
TDD는 테스트를 만드는 것부터 시작하낟. 테스트 코드를 먼저 만들고 테스트를 통과시키기 위해 코드를 구현하고 리팩토링하는 과정을 반복한다. 여기서 중요한 것은 테스트 코드를 가장 먼저 작성해야 한다는 점이다.
테스트 코드를 위해 필요한점은 다음과 같다.
- 테스트할 기능을 실행
	- 클래스 이름
	- 메서드 이름
	- 메서드 파라미터 정의
- 실행 결과를 검증
	- 리턴 값, 리턴 타입 정의

위의 과정은 곧 설계의 과정이다. 타입의 이름을 정의하고, 타입이 제공할 기능을 결정하는 것은 기본적인 설계 행위이다.
TDD를 하다보면 테스트 코드를 작성하는 과정에서 일부 설계를 진행하게 된다.

> 이름은 설계에서 매우 중요하다. 설계 과정에서 구현하는 기능을 저확하게 표현하는 이름을 사용하는 것만큼 중요한 것은 없다. 잘못 지은 이름은 두고두고 개발자를 속인다. 레거시 코드를 보면 이름에서 기대하는 것과 다르게 동작하는 코드를 종종 만나게 된다. 이런 이름은 개발자를 속일 뿐만 아니라 코드를 분석하는 시간을 증가시켜 코드 수정을 어렵게 만드는 원인이 된다.
> 시간이 다소 걸리더라도 설계시점에 알맞은 이름을 찾아야한다. 이름을 고민하는 시간을 아까워하지 말아야한다.

### 필요한 만큼만 설계하기
TDD는 테스트를 통과할 만큼만 코드를 작성한다. 필요할 것으로 예측해서 미리 코드를 만들지 않는다.
이와 관련하여 미리 앞서서 필요해 보이는 익셉션 타입을 만들지 않는다. 테스트를 진행하는 과정에서 실제 익셉션이 필요한 시점에 익셉션을 도출한다.

유연한 설계는 필요한 시점에 추가한다. 이를 통해 설계가 불필요하게 복잡해지는 것을 방지할 수 있다.
요구사항은 계속해서 변경되지 마련이므로 처음에 필요하다고 생각했던 설계 요소가 구현 과정에서 쓸모가 없어지기도 하고 반대로 처음에 예상하지 못했던 설계 요소가 나중에 출현하기도 한다.
TDD는 미리 앞서서 코드를 만들지 않으므로 불필요한 구성 요소를 덜 만들게 된다.

### 기능 명세 구체화
테스트 코드를 작성하기 앞서 개발자는 기능 명세를 정리해야 하낟.
보통 개발자는 기획자가 적성한 스토리보드나 와이어프레임과 같은 형태로 요구사항 명세를 전달받는다.
이런 문서는 사용자나 기획자가 보기에는 적당할지 모르나 개발자가 기능을 구현하기에는 생략된 내용이 많다.

테스트코드의 파라미터와 결과값을 정해야하므로 요구사항 문서에서 기능의 입력과 결과를 도출해야 하는데 텟트 사례를 추가하는 과정에서 구현하기 애매한 점들을 많이 발견하게 된다.
테스트 코드를 작성하기 위해서는 입력과 결과가 명확해야 하므로 애매한 점을 발견하면 기획자나 실무 담당자와 얘기해서 기능 명세를 구체화 해야한다.

테스트 코드는 바로 실행할 수 있다. 테스트 코드를 이용하면 구체적인 예를 이용해서 기능을 바로 실행해 볼 수 있다. 이는 유지보수에 큰 도움이 된다. 특정 상황에서 코드가 어떻게 동작 하는지 이해하고 싶다면 해당 상황을 검증하는 테스트를 실행하고 이해가 필요한 코드를 추적하면 된다.

> 복잡한 로직을 구현해야 하는 것은 결국 개발자이므로 개발자는 최대한 예외적인 상황이나 복잡한 상황에 해당하는 구체적인 예를 끄집어내야 한다. 이를 위한 가장 좋은 방법은 담당자와 대화를 하는 것이다. 대화 과정이 쉽지 않을때도 있지만 대화를 하지 않으면 올바르게 원하는 결과물을 개발하지 못한다.


## JUnit 5 기초
tdd-junit5-package![Alt text](../asset/Test/tdd-junit5-package.png)
JUnit5는 크게 세 개의 요소로 구성되어 있다.
- **JUnit Platform** - 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위함 API 제공
- **JUnit Jupiter** - JUnit 5를 위한 테스트 API와 실행 엔진을 제공
- **JUnit Vintage** - JUnit 3, JUnit 4 로 작성된 테스트를 JUnit 5 플랫폼에서 실행하기 위한 모듈을 제공

JUnit 5는 테스트를 위한 API로 주피터 API를 제공한다. 주피터 API를 사용해서 테스트를 작성하고 실행하려면 주피터 관련 모듈을 의존에 추가하면 된다.

JUnit 5를 이용해서 테스트를 실행하려면 JUnit 5 플랫폼이 제공하는 플랫폼 런처를 사용해야 한다.
Maven은 `maven-surefire-plugin:2.22.0` 버전부터 JUnit5 플랫폼을 지원하므로 따로 플랫폼 설정하지 않아도 된다.
``` xml

<dependencies>
	<dependency>
		<groupId>org.junit.jupiter</groupId>
		<artifactId>junit-jupiter</artifactId>
		<version>5.5.0</version>
		<scope>test</scope>
	</dependency>
</dependencies>

<build>
	<plugins>
		<plugin>
			<artifactId>maven-surefire-plugin</artifactId>
			<version>2.22.1</version>
		</plugin>
	</plugins>
</build>
```

Gragle의 경우 `test` task 내부에 JUnit Platform을 사용한다고 명시를 해준다.
``` gradle
dependencies {
	testImplementation('org.junit.jupiter:junit.jupiter:5.5.0')
}

test {
	useJUnitPlatform()
	...
}
```

### 주요 메서드
|메서드|설명|
|:-|:-|
|assertEquals(expected, actual)|실제값이 특정값과 같은지 검사|
|assertNotEquals(unexpected, actual)|실제값이 특정값과 같이 않은지 검사|
|assertSame(Object expected, Object actual)|두 객체가 동일한 객체인지 검사|
|assertNotSame(Object unexpected, Object actual)|두 객체가 동일하지 않은 객체인지 검사|
|assertTrue(boolean condition)|값이 true인지 검사|
|assertFalse(boolean condition)|값이 false인지 검사|
|assertNull(Object actual)|값이 null인지 검사|
|assertNotNull(Object actual)|값이 null이 아닌지 검사|
|fail()|테스트를 실패 처리한다.|
|assertThrows(Class<T> expectedType, Executable executable)|executable을 실행한 결과로 지정한 타입의 익셉션이 발생하는지 검사|
|assertDoesNotThrow(Executable executable)|executable을 실행한 결과로 익셉션이 발생하지 않는지 검사|

### 테스트 라이프 사이클

#### @BeforeEach, @AfterEach
JUnit은 각 테스트 메서드마다 다음 순서대로 코드를 실행한다.
1. 테스트 메서드를 포함한 객체 생성
2. `@BeforeEach` 애노테이션이 붙은 메서드 실행
3. `@Test` 애노테이션이 붙은 메서드 실행
4. `@AfterEach` 애노테이션이 붙은 메서드 실행

> 각 `@Test`마다
> `생성자`-> `@BeforeEach` -> `@Test`-> `@AfterEach`  순으로 항상 실행
> `@BeforeEach`, `@AfterEach`, `@Test` 가 붙은 메소드는 private여서는 안된다.


#### @BeforeAll, @AfterAll
한 클래스의 모든 테스트 메서드가 실행되기 전에 특정 작업을 수행해야 한다면 `@BeforeAll` 애노테이션을 사용한다. `@BeforeAll` 메서드는 클래스의 모든 테스트 메서드를 실행하기 전에 한 번 실행된다.
`@AfterAll` 애노테이션은 반대로 클래스의 모든 테스트 메서드를 실행한 뒤에 실행된다.

#### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기
JUnit은 테스트 메서드의 실행 순서를 지정하는 방법을 제공하고 있다. 하지만 각 테스트 메서드는 독립적으로 동작해야 한다. 테스트 메서드 간에 의존이 생기면 이는 테스트 코드의 유지보수를 어렵게 만든다. 테스트 코드 역시 코드이므로 유지보수가 중요하다. 테스트 코드를 작성할 때에는 이 점에 유념해야 한다.

#### Display 관련 Annotation
자바는 메서드 이름에 공백이나 특수 문자를 사용할 수 없기 때문에 메서드 이름만으로 테스트 내용을 설명하기가 부족할 수 있다. 이럴 때는 `@DisplayName` 애노테이션을 사용해서 테스트에 표시 이름을 붙일 수 있고 특정 테스트를 실행하지 않고 싶을 때는 `@Disabled`애노테이션을 사용하여 테스트 실행 대상에서 제외할 수 있다.
``` java
@DisplayName("@DisplayName 테스트")
public class DisplayNameTest {
	@DisplayName("값 같은지 비교")
	@Test
	void assertEqualsMethod() {
		...
	}

	@Disabled
	@Test
	void assertAllTest() {
		...
	}
}
```
> `@Disable` 관련하여 여러가지 관련된 어노테이션들이 있다.
> @EnabledOnOs, @DisabledOnOs
> @EnabledOnJre, @DisabledOnJre
> @EnabledIfSystemProperty, @DisabledSyustemProperty
> @EnabledIfEnvironmentVariable, @DisabledIfEnvironmentVariable

#### 모든 테스트 실행하기
- mvn  test (mvnw test)
- gradle test (gradlew test)


## 테스트 코드 구성
### 구성요소 : 상황, 실행, 결과 확인
테스트 코드는 기능을 실행하고 그 결과를 확인하므로 상황 실행 결과 확인의
테스트 코드를 구성할때에는 `상황`, `실행`, `결과 확인` 세 가지 요소로 테스트를 구성 할 수 있다. 어떤 상황이 주어지고 그 상황에서 기능을 실행하고, 그 상황에서 기능을 실행하고, 실행한 결과를 확인하는 세 가지가 테스트 코드의 기본 골격을 이루게 된다.
> 상황, 실행, 결과 확인은 영어로 given, when, then 으로 표시한다.

하지만 상황-실행-결과 확인 구조가 테스트 코드를 작성하는데 도움이 되는 것은 맞지만 꼭 모든 테스트 메서드를 이 구조로 만들어야 하는 것은 아니다.

### 외부 상태가 테스트 결과에 영향을 주지 않게 하기
TDD를 진행하면서 테스트코드는 한번만 실행되지 않고 개발이 끝난 이후에도 지속적으로 실행이 되기때문에 상황에 따라 간헐적으로 실패하거나 다른 테스트 다음에 실행해야 성공하는 테스트가 나올 수 있다.
예를들어 아이디 생성하여 검사하는 테스트를 만들면 디비에는 아이디가 남게되고 다음 테스트에서는 아이디가 존재하는것으로 판단되어 테스트가 실패하게 된다.
이렇게 외부 상태에 따라 테스트의 성공 여부가 바뀌지 않으려면 테스트 실행 전에 외부를 원하는 상태로 만들거나 테스트 실행 후에 외부 상태를 원래대로 되돌려 놓아야 한다.
> 대표적인 예로는 트랜젝션을 이용한 롤백이 있다.

### 외부 상태와 테스트 어려움
상황과 결과에 영향을 주는 외부 요인은 파일, DBMS, 외부 서버 등 다양하다. 이들 외부 환경을 테스트에 맞게 구성하는 것이 항상 가능한 것이 아니다.
 REST API 서버에 연결할 수 없는 상황이나 REST API 서버에서 지정한 시간 안에 응답을 주지 않는 상황을 임의적으로 만들수가 없다.
이처럼 테스트 대상이 아닌 외부 요인은 테스트 코드에서 다루기 힘든 존재이다. 외부 상황은 테스트 코드에서 마음대로 제어할 수 없는 경우가 있다.
 또한, 테스트 코드에서 생성한 외부 결과를 마음대로 초기화하기 불가능 할 때도 있다. 이렇게 테스트 대상의 상황과 결과에 외부 요인이 관여할 경우 대역을 사용하면 테스트 작성이 쉬워진다. 대역은 테스트 대상이 의존하는 대상의 실제 구현을 대신하는 구현인데 이 대역을 통해서 외부 상황이나 결과를 대체할 수 있다.

## 대역
외부 요인이 테스트에 관여하는 주요 에
- 테스트 대상에서 파일 시스템을 사용
- 테스트 대상에서 DB로부터 데이터 조회하거나 데이터를 추가
- 테스트 대상에서 외부의 HTTP 서버와 통신

테스트 대상이 이런 외부 요인에 의존하면 테스트를 작성하고 실행하기 어려워진다.
테스트 대상 코드에서 사용하는 외부 API 서버가 일시적으로 장애가 나면 테스트를 원활하게 수행할 수 없다.

TDD는 `테스트 작성 -> 통과시킬 만큼 구현 -> 리팩토링`의 사이클을  반복해야 하는데  외부에서  테스트환경이 제공되지 않거나 연동해야 하는 개발에 있어서 협업이 어려울 시기에는 대역을 통하여 테스트를 진행해야한다.

### 대역의 종류
|대역 종류|설명|
|:-|:-|
|스텁 (Stub)|구현을 단순화한 것으로 대체한다. 테스트에 맞게 단순히 원하는 동작을 수행한다.|
|가짜 (Fake)|제품에는 적합하지 않지만, 실제 동작하는 구현을 제공한다. (ex. DB 대신에 메모리를 이용)|
|스파이 (Spy)|호출된 내역을 기록한다. 기록한 내용은 테스트 결과를 검증할 때 사용한다.|
|모의 (Mock)|기대한 대로 상호작용하는지 행위를 검증한다. 기대한 대로 동작하지 않으면 Exception을 발생할 수 있다. 모의 객체는 Stub이자 Spy도 된다.|

### 상황과 결과 확인을 위한 협업 대상(의존) 도출과 대역 사용

TDD시에 제어하기 힘든 외부 상황이 존재하면 다음과 같은 방법으로 의존을 도출하고 이를 대역으로 대신할 수 있다.
- 제어하기 힘든 외부 상황을 별도 타입으로 분리
- 테스트 코드는 별도로 분리한 타입의 대역을 생성
- 생성한 대역을 테스트 대상의 생성자 등을 이용해서 전달
- 대역을 이용해서 상황 구성

### 모의 객체를 과하게 사용하지 않기
모의 객체는 스텁과 스파이를 지원하므로 대역으로 모의 객체를 많이 사용하지만 모의 객체를 과하게 사용하면 오히려 테스트 코드가 복잡해지는 경우도 발생한다.
모의 객체가 아닌 단순하게 구현하는 방법이 오히려 쉽게 테스트코드가 작성되는 경우도 있다.
모의 객체를 이용하면 대역 객체를 따로 만들지 않아도되어 편할 수 있지만 결과 값을 확인하는 수단으로 모의 객체를 사용하기 시작하면 결과 검증 코드가 길어지고 복잡해진다.
 특히 하나의 테스트를 위해 여러 모의 객체를 사용하기 시작하면 결과 검증 코드의 복잡도는 배로 증가하게 된다.
  기본적으로 메서드 호출 여부를 검증하는 수단이기 때문에 테스트 대상과 모의 객체 간의 상호 작용이 조금만 바뀌어도 테스트가 깨지기 쉽다.

## 테스트 가능한 설계

### 테스트가 어려운 코드

#### 하드 코딩된 경로
파일 경로가 하드코딩 되어있는 경우 경로가 윈도우라면 맥 사용자들은 그 테스트를 진행할 수 없다.
경로뿐만 아니라 하드코딩 된 IP, PORT 또한 테스트를 어렵게 만든다.

> **해결방법**
> 해당 상황에 대해서는 하드코딩된 상수를 생성자나 메서드 파라미터로 이동하여 교체가 가능하게 설계를 해야한다.
> 가장 쉬운 방법은 Setter 혹은 생성자에서 받거나 실행하는 함수의 인자값으로 전달받는것이다.
> 테스트 코드에서 데이터를 읽을 때 사용하는 파일은 소스 코드 리포지토리에 함께 등록해야 한다.
> `src/test/file`, `src/test/resource`가 정당한 위치이다.

#### 의존객체를 직접 생성
의존 대상을 객체 내에서 직접 생성하여 사용한다면 테스트에서 똑같은 조건을 맞추기가 힘들어지는 경우가 있다.
> **해결방법**
> 의존 대상은 주입 받을 수 있는 수단을 제공해서 교체할 수 있도록 한다.
> 생성자나 Setter를 통해 의존 대상을 교체할 수 있도록 설계하여 대역을 사용 가능하게끔 만들어준다.

#### 정적메소드 사용
테스트를 진행해야하는 코드가 정적 클래스의 정적 메서드를 사용하고 있다면 해당 기능의 테스트 환경을 만들기가 쉽지 않다.
정적메서드가 서버 통신이나 시스템 프로퍼티에서 서버 정보를 가지고온다면 개발환경에 맞춰서 시스템 프로퍼티에 아이디와 비밀번호를 다시 구성해줘야 하는 문제도 생긴다.
> **해결방법**
> 정적메소드와 테스트 해야하는 코드가 다른 의존관계에 강하게 결합이 되어있다면 테스트 하고싶은 부분만 뗴어내서  따로 클래스를 구성해서 외부 주입과 테스트 환경에서 동작이 가능하게끔 유연한 설계를 가저가는것이 좋다.

#### 실행 시점에 따라 달라지는 결과
실제 실행 함수에 LocalDate.now()를 가져와 완료시점을 판단하여 실행시점에 따라 결과가 달라지는 경우나 Random을 사용하여 임의의 값을 사용하는 경우도 실행시마다 테스트가 성공/실패 할 수있어 믿을 수 없는 테스트 코드가 생기게된다.
> **해결방법**
> 시간이나 임의의 값을 제공하는 기능을 별도로 분리해서 테스트 가능성을 높일 수 있다.
> LocalDate.now() 같은 기능을 해당기능을 제공하는 클래스를 따로 뺀 뒤 today()라는 함수에서 LocalDate.now()를 리턴하도록 구현한다.

#### 외부 라이브러리 사용
테스트 대상이 사용하는 외부 라이브러리를 쉽게 대체할 수 없는 경우도 있다. 외부 라이브러리가 정적 메서드를 제공한다면 대체할 수 없다.
> **해결방법**
> 이렇게 대역으로 대체하기 어려운 라이브러리가 있다면 외부 라이브러리를 직접 사용하지 말고 외부 라이브러리와 연동하기 위한 Wrapper class를 따로 만들어준다.
> 그리고 테스트 대상은 그 Wrapper class를 사용하게 함으로 외부 연동이 필요한 기능을 쉽게 대역으로 대체할 수 있게 된다.

#### 그 외 테스트가 어려운 코드
- 역할이 섞여있는 코드
- 메서드 중간에 소켓 통신 코드가 포함
- 콘솔에서 입력을 받거나 결과를 콘솔에 출력
- 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final인 경우 대역으로 대체가 어려움
- 테스트 대상의 소스를 소유하고 있지 않아 수정이 어려운 경우

## 테스트 범위와 종류
### 단위 테스트 (Unit Test)
![단위 테스트](../asset/Test/tdd-testarea-01-2.png)

개별 코드나 컴포넌트가 기대한대로 동작하는지 확인하는 테스트
단위 테스트는 한 클래스나 한 메서드와 같은 작은 범위를 테스트한다.
일부 의존 대상은 스텁이나 모의 객체 등을 이용해서 대역으로 대체한다.


### 통합테스트 (Integration Test)
![통합 테스트](../asset/Test/tdd-testarea-02.png)
시스템의 각 구성 요소가 올바르게 연동되는지 확인하는 테스트
기능 테스트가 사용자 입장에서 테스트하는 데 반해 통합 테스트는 소프트웨어의 코드를 직접 테스트한다. 모바일 앱을 예로 들면 기능 테스트는 앱을 통해 가입 기능을 테스트 한다면 통합 테스트는 서버의 회원 가입 코드를 직접 테스트 하는 식이다.
 스프링 프레임워크나 마이바티스 설정이 올바른지 SQL 쿼리가 맞는지 DB트렌젝션이 잘 동작하는지 등을 검증 할 수 있다.

### 기능테스트 (Functional Test)
![기능 테스트](../asset/Test/tdd-testarea-03.png)
기능 테스트는 사용자 입장에서 시스템이 제공하는 기능이 올바르게 동작하는지 확인한다.
이 테스트를 수행하려면 시스템을 구동하고 사용하는데 필요한 모든 구성 요소가 필요하다.
사용자가 직접 사용하는 웹 브라우저나 모바일 앱부터 시작해서 데이터베이스나 외부 서비스에 이르기까지 모든 구성 요소를 하나로 엮어서 진행한다.
이는 E2E(End To End)의 모든 구성 요소를 논리적으로 완전한 하나의 기능으로 다룬다.
QA 조직에서 수행하는 테스트가 이 기능 테스트이다.

### 테스트 범위간 차이
|분류|통합 테스트|기능 테스트|단위 테스트|
|:-:|:-|:-|:-|
|테스트 환경 구성|DB, 캐시 서버등 연동 대상을 구성|별도구성 필요없음|별도구성 필요없음|
|테스트 실행 속도|DB연결, 소켓 통신, 스프링 컨테이너 초기화와 같이 테스트실행 속도를 느리게 만드는 요인이 많다.|브라우저, 앱을 구동한 뒤 화면의 흐름에 따라 알맞은 상호 작용|서버구동 및 DB 연결 없이 대역으로만 처리 가능|
|외부 연동 요인|외부연동 없인 테스트 불가|외부연동 없인 테스트 불가|대역을 통한 테스트가 가능|
|속도|느림|중간|빠름|
|테스트 코드 개수|적음|중간|많음|

TDD를 하는지 여부에 상관없이 테스트 코드를 작성하는 개발자는 단위 테스트와 통합 테스트를 섞어서 작성하게 된다.
보통 통합 테스트보다는 단위 테스트 코드를 더 많이 작성한다.

단위 테스트는 통합 테스트로도 만들기 힘든 상황을 쉽게 구성할 수 있다.
더 작은 단위를 대상으로 테스트 코드를 만들고 더 다양한 상황을 다르기 때문에 통합 테스트보다 단위 테스트 코드를 더 많이 작성한다.

기능테스트나 통합테스트에서 모든 예외 상황을 테스트한다면 중복되는 단위 테스트가 줄어들지만 단위 테스트의 속도는 다른것보다 월등히 빠르기 떄문에 가능하면 단위 테스트에서 다양한 상황을 다루고 통합테스트나 기능 테스트는 주요 상황에 초점을 맞춰야 한다.

테스트 실행속도가 느려지면 테스트를 작성하지 않거나 테스트 실행을 생략하는 상황이 벌어지며 이는 곧 소프트웨어의 품질 저하로 이어질 수 있기 때문에 가능하면 빠른 시간 내에 테스트를 실행할 수 있도록 해야한다.

