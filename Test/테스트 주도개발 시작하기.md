#TDD

<!--[TOC]: # "## Table of Contents"-->
## Table of Contents
- [환경설정](#환경설정)
- [테스트 코드 작성 순서](#테스트-코드-작성-순서)
  - [완급조절](#완급조절)
  - [지속적인 리팩토링](#지속적인-리팩토링)
- [TDD.기능 명세.설계](#tdd기능-명세설계)
  - [필요한 만큼만 설계하기](#필요한-만큼만-설계하기)
  - [기능 명세 구체화](#기능-명세-구체화)
- [JUnit 5 기초](#junit-5-기초)
  - [주요 메서드](#주요-메서드)
  - [테스트 라이프 사이클](#테스트-라이프-사이클)
- [테스트 코드 구성](#테스트-코드-구성)
  - [구성요소 : 상황, 실행, 결과 확인](#구성요소--상황-실행-결과-확인)
  - [외부 상태가 테스트 결과에 영향을 주지 않게 하기](#외부-상태가-테스트-결과에-영향을-주지-않게-하기)
  - [외부 상태와 테스트 어려움](#외부-상태와-테스트-어려움)

## TDD란?
TDD는 테스트부터 시작한다.
구현을 먼저 하는것이 아닌 테스트 케이스를 먼저 만든다음 구현을 뒤로 미룬다.
기능을 검증하는 테스트 코드를 먼저 작성하고 테스트를 통과시키기 위해 개발을 진행하는것을 의미한다.
작성한 테스트를 통과하지 못하면 테스트를 통과할 만큼만 코드를 작성한다.
테스트를 통과한 뒤에는 개선할 코드가 있으면 리팩토링한다.
리팩토링을 수행한 뒤에는 다시 테스트를 실행해서 기존 기능이 망가지지 않았는지 확인한다.
이 과정을 반복하면서 점진적으로 기능을 완성해 나가는 것, 이것이 전형적인 TDD의 흐름이다.

테스트코드를 작성할 때 `src/main/java`에 먼저 만들기 보다는 `src/test/java`에 먼저 구현한뒤 테스트 코드가 완성되면 `src/main/java`로 이동한다. 이렇게 한다면 완성되지 않은 코드가 배포되는 것을 방지하는 효과가 있다.


> **레드-그린-리팩터**
> TDD 사이클을 Red-Green-Refactor로 부르기도 한다.
> 여기서 레드는 실패하는 테스트를 의미한다. 테드는 테스트 코드가 실패하면 빨간색을 이용해서 실패한 테스트를 보여주는데서 비롯했다.
> 비슷하게 그린은 성공한 테스트를 의미한다. 즉 코드를 구현해서 실패하는 테스트를 통과시키는 것을 뜻한다.
> 마지막으로 리팩터는 이름 그대로 리팩토링 과정을 의미한다.


## 환경설정
Gradle 프로젝트에서 JUnit 설정
``` gradle
plugins {
    id 'java'
}

sourceCompatibility = '11'
targetCompatibility = '11'
compileJava.options.encoding = 'UTF-8'
compileTestJava.options.encoding = 'UTF-8'

repositories {
    mavenCentral()
}

dependencies {
    testImplementation('org.junit.jupiter:junit-jupiter:5.5.0')
}

test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}
```

## 테스트 코드 작성 순서
- 쉬운 경우에서 어려운 경우로 진행
- 예외적인 경우에서 정상인 경우로 진행

반대로 어려운 경우를 먼저 시작하거나 정상 상황을 먼저 시작하면 구현 과정이 원활하게 진행되지 않기도 한다.

1. 구현하기 쉬운 테스트부터 시작
	- 구현하기 어려운 테스트부터 시작하면 구현해야 할 코드량이 많아진다.
	- 한 번에 구현하는 시간이 짧아지면 디버깅 할 때에 유리하다. 작성한 코드가 많지 않고 작성 시간도 짧으면 머릿속에 코드에 대한 내용이 생생하게 남아 있기 때문에 디버깅 할 떄 문제 원인을 빠르게 찾을 수 잇다.
2. 예외 상황을 먼저 테스트
	- 초반에 예외를 처리하지 않으면 코드를 복잡하게 만들면 버그 발생 가능성을 높인다.
	- 예외 상황에 따른 if-else 구조가 미리 만들어지기 떄문에 많은 코드를 완성한 뒤에 예외 상황을 반영할 때보다 코드 구조가 덜 바뀐다.

### 완급조절
테스트 코드를 작성할때는 하드코딩으로 테스트를 통과시키고 그 다음에 하드코딩했던 상수를 제거하고 구현을 일반화한다.
몇 차례 상수를 사용해서 테스트를 통과시키고 뒤에 구현을 일반화 하는 과정이 처음에는 지루하게 느껴질 수도 있지만 이런 연습 과정은 나중에 만들어야 할 코드가 잘 떠오르지 않을 때 점진적으로 구현을 진행할 수 있는 밑거름이 된다.

### 지속적인 리팩토링
테스트를 통과하면 리팩토링을 진행한다.
매번 리팩토링을 진행하는것은 아니지만 적당한 후보가 보이면 리팩토링을 진행한다.
코드 중복은 대표적인 리팩토링 대상이고 코드가 길어지면 메서드 추출과 같은 기법을 사용해서 메서드 이름으로 코드의 의미를 표현할 수 있다.


## TDD.기능 명세.설계
TDD는 테스트를 만드는 것부터 시작하낟. 테스트 코드를 먼저 만들고 테스트를 통과시키기 위해 코드를 구현하고 리팩토링하는 과정을 반복한다. 여기서 중요한 것은 테스트 코드를 가장 먼저 작성해야 한다는 점이다.
테스트 코드를 위해 필요한점은 다음과 같다.
- 테스트할 기능을 실행
	- 클래스 이름
	- 메서드 이름
	- 메서드 파라미터 정의
- 실행 결과를 검증
	- 리턴 값, 리턴 타입 정의

위의 과정은 곧 설계의 과정이다. 타입의 이름을 정의하고, 타입이 제공할 기능을 결정하는 것은 기본적인 설계 행위이다.
TDD를 하다보면 테스트 코드를 작성하는 과정에서 일부 설계를 진행하게 된다.

> 이름은 설계에서 매우 중요하다. 설계 과정에서 구현하는 기능을 저확하게 표현하는 이름을 사용하는 것만큼 중요한 것은 없다. 잘못 지은 이름은 두고두고 개발자를 속인다. 레거시 코드를 보면 이름에서 기대하는 것과 다르게 동작하는 코드를 종종 만나게 된다. 이런 이름은 개발자를 속일 뿐만 아니라 코드를 분석하는 시간을 증가시켜 코드 수정을 어렵게 만드는 원인이 된다.
> 시간이 다소 걸리더라도 설계시점에 알맞은 이름을 찾아야한다. 이름을 고민하는 시간을 아까워하지 말아야한다.

### 필요한 만큼만 설계하기
TDD는 테스트를 통과할 만큼만 코드를 작성한다. 필요할 것으로 예측해서 미리 코드를 만들지 않는다.
이와 관련하여 미리 앞서서 필요해 보이는 익셉션 타입을 만들지 않는다. 테스트를 진행하는 과정에서 실제 익셉션이 필요한 시점에 익셉션을 도출한다.

유연한 설계는 필요한 시점에 추가한다. 이를 통해 설계가 불필요하게 복잡해지는 것을 방지할 수 있다.
요구사항은 계속해서 변경되지 마련이므로 처음에 필요하다고 생각했던 설계 요소가 구현 과정에서 쓸모가 없어지기도 하고 반대로 처음에 예상하지 못했던 설계 요소가 나중에 출현하기도 한다.
TDD는 미리 앞서서 코드를 만들지 않으므로 불필요한 구성 요소를 덜 만들게 된다.

### 기능 명세 구체화
테스트 코드를 작성하기 앞서 개발자는 기능 명세를 정리해야 하낟.
보통 개발자는 기획자가 적성한 스토리보드나 와이어프레임과 같은 형태로 요구사항 명세를 전달받는다.
이런 문서는 사용자나 기획자가 보기에는 적당할지 모르나 개발자가 기능을 구현하기에는 생략된 내용이 많다.

테스트코드의 파라미터와 결과값을 정해야하므로 요구사항 문서에서 기능의 입력과 결과를 도출해야 하는데 텟트 사례를 추가하는 과정에서 구현하기 애매한 점들을 많이 발견하게 된다.
테스트 코드를 작성하기 위해서는 입력과 결과가 명확해야 하므로 애매한 점을 발견하면 기획자나 실무 담당자와 얘기해서 기능 명세를 구체화 해야한다.

테스트 코드는 바로 실행할 수 있다. 테스트 코드를 이용하면 구체적인 예를 이용해서 기능을 바로 실행해 볼 수 있다. 이는 유지보수에 큰 도움이 된다. 특정 상황에서 코드가 어떻게 동작 하는지 이해하고 싶다면 해당 상황을 검증하는 테스트를 실행하고 이해가 필요한 코드를 추적하면 된다.

> 복잡한 로직을 구현해야 하는 것은 결국 개발자이므로 개발자는 최대한 예외적인 상황이나 복잡한 상황에 해당하는 구체적인 예를 끄집어내야 한다. 이를 위한 가장 좋은 방법은 담당자와 대화를 하는 것이다. 대화 과정이 쉽지 않을때도 있지만 대화를 하지 않으면 올바르게 원하는 결과물을 개발하지 못한다.


## JUnit 5 기초
tdd-junit5-package![Alt text](../asset/Test/tdd-junit5-package.png)
JUnit5는 크게 세 개의 요소로 구성되어 있다.
- **JUnit Platform** - 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위함 API 제공
- **JUnit Jupiter** - JUnit 5를 위한 테스트 API와 실행 엔진을 제공
- **JUnit Vintage** - JUnit 3, JUnit 4 로 작성된 테스트를 JUnit 5 플랫폼에서 실행하기 위한 모듈을 제공

JUnit 5는 테스트를 위한 API로 주피터 API를 제공한다. 주피터 API를 사용해서 테스트를 작성하고 실행하려면 주피터 관련 모듈을 의존에 추가하면 된다.

JUnit 5를 이용해서 테스트를 실행하려면 JUnit 5 플랫폼이 제공하는 플랫폼 런처를 사용해야 한다.
Maven은 `maven-surefire-plugin:2.22.0` 버전부터 JUnit5 플랫폼을 지원하므로 따로 플랫폼 설정하지 않아도 된다.
``` xml

<dependencies>
	<dependency>
		<groupId>org.junit.jupiter</groupId>
		<artifactId>junit-jupiter</artifactId>
		<version>5.5.0</version>
		<scope>test</scope>
	</dependency>
</dependencies>

<build>
	<plugins>
		<plugin>
			<artifactId>maven-surefire-plugin</artifactId>
			<version>2.22.1</version>
		</plugin>
	</plugins>
</build>
```

Gragle의 경우 `test` task 내부에 JUnit Platform을 사용한다고 명시를 해준다.
``` gradle
dependencies {
	testImplementation('org.junit.jupiter:junit.jupiter:5.5.0')
}

test {
	useJUnitPlatform()
	...
}
```

### 주요 메서드
|메서드|설명|
|:-|:-|
|assertEquals(expected, actual)|실제값이 특정값과 같은지 검사|
|assertNotEquals(unexpected, actual)|실제값이 특정값과 같이 않은지 검사|
|assertSame(Object expected, Object actual)|두 객체가 동일한 객체인지 검사|
|assertNotSame(Object unexpected, Object actual)|두 객체가 동일하지 않은 객체인지 검사|
|assertTrue(boolean condition)|값이 true인지 검사|
|assertFalse(boolean condition)|값이 false인지 검사|
|assertNull(Object actual)|값이 null인지 검사|
|assertNotNull(Object actual)|값이 null이 아닌지 검사|
|fail()|테스트를 실패 처리한다.|
|assertThrows(Class<T> expectedType, Executable executable)|executable을 실행한 결과로 지정한 타입의 익셉션이 발생하는지 검사|
|assertDoesNotThrow(Executable executable)|executable을 실행한 결과로 익셉션이 발생하지 않는지 검사|

### 테스트 라이프 사이클

#### @BeforeEach, @AfterEach
JUnit은 각 테스트 메서드마다 다음 순서대로 코드를 실행한다.
1. 테스트 메서드를 포함한 객체 생성
2. `@BeforeEach` 애노테이션이 붙은 메서드 실행
3. `@Test` 애노테이션이 붙은 메서드 실행
4. `@AfterEach` 애노테이션이 붙은 메서드 실행

> 각 `@Test`마다
> `생성자`-> `@BeforeEach` -> `@Test`-> `@AfterEach`  순으로 항상 실행
> `@BeforeEach`, `@AfterEach`, `@Test` 가 붙은 메소드는 private여서는 안된다.


#### @BeforeAll, @AfterAll
한 클래스의 모든 테스트 메서드가 실행되기 전에 특정 작업을 수행해야 한다면 `@BeforeAll` 애노테이션을 사용한다. `@BeforeAll` 메서드는 클래스의 모든 테스트 메서드를 실행하기 전에 한 번 실행된다.
`@AfterAll` 애노테이션은 반대로 클래스의 모든 테스트 메서드를 실행한 뒤에 실행된다.

#### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기
JUnit은 테스트 메서드의 실행 순서를 지정하는 방법을 제공하고 있다. 하지만 각 테스트 메서드는 독립적으로 동작해야 한다. 테스트 메서드 간에 의존이 생기면 이는 테스트 코드의 유지보수를 어렵게 만든다. 테스트 코드 역시 코드이므로 유지보수가 중요하다. 테스트 코드를 작성할 때에는 이 점에 유념해야 한다.

#### Display 관련 Annotation
자바는 메서드 이름에 공백이나 특수 문자를 사용할 수 없기 때문에 메서드 이름만으로 테스트 내용을 설명하기가 부족할 수 있다. 이럴 때는 `@DisplayName` 애노테이션을 사용해서 테스트에 표시 이름을 붙일 수 있고 특정 테스트를 실행하지 않고 싶을 때는 `@Disabled`애노테이션을 사용하여 테스트 실행 대상에서 제외할 수 있다.
``` java
@DisplayName("@DisplayName 테스트")
public class DisplayNameTest {
	@DisplayName("값 같은지 비교")
	@Test
	void assertEqualsMethod() {
		...
	}

	@Disabled
	@Test
	void assertAllTest() {
		...
	}
}
```
> `@Disable` 관련하여 여러가지 관련된 어노테이션들이 있다.
> @EnabledOnOs, @DisabledOnOs
> @EnabledOnJre, @DisabledOnJre
> @EnabledIfSystemProperty, @DisabledSyustemProperty
> @EnabledIfEnvironmentVariable, @DisabledIfEnvironmentVariable

#### 모든 테스트 실행하기
- mvn  test (mvnw test)
- gradle test (gradlew test)


## 테스트 코드 구성
### 구성요소 : 상황, 실행, 결과 확인
테스트 코드는 기능을 실행하고 그 결과를 확인하므로 상황 실행 결과 확인의
테스트 코드를 구성할때에는 `상황`, `실행`, `결과 확인` 세 가지 요소로 테스트를 구성 할 수 있다. 어떤 상황이 주어지고 그 상황에서 기능을 실행하고, 그 상황에서 기능을 실행하고, 실행한 결과를 확인하는 세 가지가 테스트 코드의 기본 골격을 이루게 된다.
> 상황, 실행, 결과 확인은 영어로 given, when, then 으로 표시한다.

하지만 상황-실행-결과 확인 구조가 테스트 코드를 작성하는데 도움이 되는 것은 맞지만 꼭 모든 테스트 메서드를 이 구조로 만들어야 하는 것은 아니다.

### 외부 상태가 테스트 결과에 영향을 주지 않게 하기
TDD를 진행하면서 테스트코드는 한번만 실행되지 않고 개발이 끝난 이후에도 지속적으로 실행이 되기때문에 상황에 따라 간헐적으로 실패하거나 다른 테스트 다음에 실행해야 성공하는 테스트가 나올 수 있다.
예를들어 아이디 생성하여 검사하는 테스트를 만들면 디비에는 아이디가 남게되고 다음 테스트에서는 아이디가 존재하는것으로 판단되어 테스트가 실패하게 된다.
이렇게 외부 상태에 따라 테스트의 성공 여부가 바뀌지 않으려면 테스트 실행 전에 외부를 원하는 상태로 만들거나 테스트 실행 후에 외부 상태를 원래대로 되돌려 놓아야 한다.
> 대표적인 예로는 트랜젝션을 이용한 롤백이 있다.

### 외부 상태와 테스트 어려움
상황과 결과에 영향을 주는 외부 요인은 파일, DBMS, 외부 서버 등 다양하다. 이들 외부 환경을 테스트에 맞게 구성하는 것이 항상 가능한 것이 아니다.
 REST API 서버에 연결할 수 없는 상황이나 REST API 서버에서 지정한 시간 안에 응답을 주지 않는 상황을 임의적으로 만들수가 없다.
이처럼 테스트 대상이 아닌 외부 요인은 테스트 코드에서 다루기 힘든 존재이다. 외부 상황은 테스트 코드에서 마음대로 제어할 수 없는 경우가 있다.
 또한, 테스트 코드에서 생성한 외부 결과를 마음대로 초기화하기 불가능 할 때도 있다. 이렇게 테스트 대상의 상황과 결과에 외부 요인이 관여할 경우 대역을 사용하면 테스트 작성이 쉬워진다. 대역은 테스트 대상이 의존하는 대상의 실제 구현을 대신하는 구현인데 이 대역을 통해서 외부 상황이나 결과를 대체할 수 있다.



